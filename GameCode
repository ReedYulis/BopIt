#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <stdbool.h>
#include "SoftwareSerial.h"
#include "DFRobotDFMiniPlayer.h"
#include <Wire.h>
#include "SparkFun_CAP1203.h" // Click here to get the library: http://librarymanager/All#SparkFun_CAP1203

CAP1203 sensor; // Initialize sensor

#define ROT_B 4        // rotary B
#define ROT_A 3          // rotary A

int state = 0; //state numbers: GameIdle = 0; Start = 10, Instruction = 11, User Turn = 12, Victory = 13, failure = 14
int instr = 0; //instruction coding numbers : Launch = 1, Slide = 2, Twist = 3
int score = 0;
int units = 0;
int tens = 0;
int doThis = 0;
int sleepTimer = 0;
volatile int rotary_counter = 0; // current "position" of rotary encoder (increments CW);
volatile boolean rotary_change = false; // will turn true if rotary_counter has changed;
DFRobotDFPlayerMini myMP3Player;
void setup() {

  attachInterrupt(1, rotaryIRQ, CHANGE);
  
  Wire.begin();       // Join I2C bus
  Serial.begin(9600); // Start serial for output
  pinMode(8, OUTPUT); //LEDs for Slide
  pinMode(7, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(4, INPUT); //rotary encoder A
  pinMode(2, INPUT); //rotary encoder B
  pinMode(1, INPUT);// push button it
}


void rotaryIRQ()
{
  // Process input from the rotary encoder.
  // The rotary "position" is held in rotary_counter, increasing for CW rotation (changes by one per detent).
  // If the position changes, rotary_change will be set true. (You may manually set this to false after handling the change).

  // This function will automatically run when rotary encoder input A transitions in either direction (low to high or high to low)
  // By saving the state of the A and B pins through two interrupts, we'll determine the direction of rotation
  // int rotary_counter will be updated with the new value, and boolean rotary_change will be true if there was a value change
  // Based on concepts from Oleg at circuits@home (http://www.circuitsathome.com/mcu/rotary-encoder-interrupt-service-routine-for-avr-micros)
  // Unlike Oleg's original code, this code uses only one interrupt and has only two transition states;
  // it has less resolution but needs only one interrupt, is very smooth, and handles switchbounce well.

  static unsigned char rotary_state = 0; // current and previous encoder states

  rotary_state <<= 2;  // remember previous state
  rotary_state |= (digitalRead(ROT_A) | (digitalRead(ROT_B) << 1));  // mask in current state
  rotary_state &= 0x0F; // zero upper nybble


  if (rotary_state == 0x09) // from 10 to 01, increment counter. Also try 0x06 if unreliable
  {
    rotary_counter++;
    rotary_change = true;
  }
  else if (rotary_state == 0x03) // from 00 to 11, decrement counter. Also try 0x0C if unreliable
  {
    rotary_counter--;
    rotary_change = true;
  }
}


int pickAction()
{
  return random(3) + 1;
}
void declareAction(int instruction)
{
  int whichFile = 0;

  if (instruction == 1)
  {
    whichFile = 31;
  }
  else if (instruction == 2)
  {
    whichFile = 33;
  }
  else if (instruction == 3)
  {
    whichFile = 35;
  }
  myMP3Player.play(whichFile);
}
void endGame()
{
  units = score % 10;
  tens = (score - units) / 10;
  //play mp3 corresponding with failure
  myMP3Player.play(28);
  if (score == 99)
  {
    //play victory file
    myMP3Player.play(36);
  }
  else if (score < 20)
  {
    //play mp3 for 0-19 (most likely some form of play(base address + score)
    myMP3Player.play(score);
  }
  else
  {
    //play mp3 for tens digit
    myMP3Player.play(tens + 18);
    //play mp3 for units digit
    myMP3Player.play(units);
  }
}

bool success(int action) //prototype for success checker
{
  bool nailedIt = false;
  int i = 0;
  while (i < 1000) //this number can and should be messed with to determine a good time interval. Can also be turned into a difficulty variable with multiple settings
  {
    switch (action)
    {
      case 1:
      {
        if (sensor.isTouched() || rotary_change)
        {
          i = 1000;
        }
        else if (!digitalRead(1)) // Launch Input
        {
          nailedIt = true;
          myMP3Player.play(37);
        }
      }
      break;
      case 2:
      {
        if (!digitalRead(1) || rotary_change)
        {
          i = 1000;
        }
        else if (sensor.isTouched())
        {
          nailedIt = true;
          digitalWrite(8, HIGH); // sets the digital pin 13 on
          delay(125);            // waits for a second
          digitalWrite(8, LOW);  // sets the digital pin 13 off
          delay(50); 
           digitalWrite(7, HIGH); // sets the digital pin 13 on
          delay(125);            // waits for a second
          digitalWrite(7, LOW);  // sets the digital pin 13 off
          delay(50);
          digitalWrite(6, HIGH);
          delay(125);
          digitalWrite(6, !digitalRead(6));
          myMP3Player.play(39);
        }
      }
      break;
      case 3:
      {
        if (sensor.isTouched() || !digitalRead(1))
        {
          i = 1000;
        }
        else if (rotary_change) //spin input
        {
          nailedIt = true;
          myMP3Player.play(38);
        }
      }
      break;
      default:
        break;
    }
    i++;
  }
  return nailedIt;
}

void loop() {
  // put your main code here, to run repeatedly:
  switch (state)
    {
      case 0: //GameIdle State
      {
        //play mp3 for "press button to start!"
        myMP3Player.play(30);
        while ((digitalRead(1)) && (sleepTimer < 10000)) //this number can and should be messed with to determine a good time interval.
        {
          sleepTimer++;
        }
        if (sleepTimer == 10000)
        {
          //send power off signal
        }
        state = 10;
      }
      break;
      case 10: //Game Start State
      {
        score = 1;
        state = 11; 
      }
      break;
      case 11: //Instruction State
      {
        doThis = pickAction();
        declareAction(doThis);
        delay(800);
        state = 12;
      }
      break;
      case 12: //User Turn State
      {
        if (success(doThis))
        {
          score ++;
          delay (300);
          state = 11;
        }
        else
        {
          state = 14;
        }
        if (score == 99)
        {
          state = 13;
        }
      }
      break;
      case 13: //Victory State
      {
        endGame();
        delay(5000);
        state = 0;
      }
      break;
      case 14: //Game Over State
      {
        endGame();
        delay(5000);
        state = 0;
      }
      break;
      default:
        break;
    }
}
